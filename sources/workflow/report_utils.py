import xml.etree.ElementTree as ET
from ast import literal_eval
from collections import OrderedDict
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from xml.etree.ElementTree import Element

from requirements import Requirement


class TestType(Enum):
    UNIT = "unit"
    INTEGRATION = "integration"
    SYSTEM = "system"


@dataclass
class TestCase:
    clsname: str
    name: str
    description: str
    type_: TestType

    req_ids: list[str]

    @staticmethod
    def parse(case: Element) -> "TestCase":
        properties = {it.get("name"): it.get("value") for it in case.find("properties").findall("property")}
        properties["categories"] = "'unit'"

        return TestCase(
            clsname=case.get("classname"),
            name=case.get("name"),
            description=properties["test_description"],
            type_=TestType(literal_eval(properties["categories"])),
            req_ids=literal_eval(properties["functional_specification"])
        )

    def to_dict(self):
        dict_ = OrderedDict()
        dict_["classname"] = self.clsname
        dict_["name"] = self.name
        dict_["type"] = self.type_.value
        dict_["req_ids"] = self.req_ids
        return dict_


@dataclass
class TestSuite:
    errors: int
    tests_total: int
    tests_failed: int
    tests_skipped: int

    tests: list[TestCase]

    @staticmethod
    def parse(suites: Element) -> "TestSuite":
        suite = suites.find("testsuite")
        return TestSuite(
            errors=int(suite.get("errors")),
            tests_total=int(suite.get("tests")),
            tests_failed=int(suite.get("failures")),
            tests_skipped=int(suite.get("skipped")),
            tests=[TestCase.parse(it) for it in suite.findall("testcase") if it.get("error") is not None],
        )

    def get_tests_with_incorrect_req_ids(self, all_reqs: list[Requirement]) -> list[TestCase]:
        """ Returns a list of TestCases that have at least one Requirement id referenced that is not present in the loaded requirements. """
        req_ids = {req.id for req in all_reqs}

        invalid_links = []
        for test in self.tests:
            if any([(ref_id not in req_ids) for ref_id in test.req_ids]):
                invalid_links.append(test)

        return invalid_links


_TESTSUITE: TestSuite


def parse_cur_exec_report(report_file: Path) -> TestSuite | None:
    """ Parses the last execution report (xml) generated by pytest (if available). Returns the parsed suite or None (if not available). """
    global _TESTSUITE

    if not report_file.exists():
        return None

    tree = ET.parse(report_file)
    root = tree.getroot()
    _TESTSUITE = TestSuite.parse(root)
    return _TESTSUITE


def get_current_suite() -> TestSuite | None:
    """ Returns the last execution report (xml) generated by pytest (if available else None). """
    return _TESTSUITE
